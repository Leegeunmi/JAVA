WEB

	web / internet
	HTTP / HTML 	http프로토콜
			HTTP(Hypertext Transfer Protocol)는 인터넷상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜이다.
			애플리케이션 레벨의 프로토콜로 TCP/IP위에서 작동한다.

			하이퍼텍스트 기반으로(Hypertext) 데이터를 전송하겠다(Transfer) = 링크기반으로 데이터에 접속하겠다는 의미이다.
			
			Connectionless & Stateless
			HTTP는 Connectionless 방식으로 작동한다. 
			서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버린다.
 			https://shlee0882.tistory.com/107
			1.인증받은회원인가 2.지속적으로 사용한자인가
			연결이 된건 아니지만 연결이 되어 보이게 한다. (로그인해야 연결)

			HTML은 정적문서이고 동적으로 만들기위해서 script등장
			정적문자를 애플리케이션화(동적결정에의해 필요에따라 처리하겠다)하고자 하는 것이 http
			http는 html과 같은 정적문서를 동적으로 보이게 하기위한다._애플리케이션화 하고있다.
			초기에는 장점이였으나 갈수록 단점화..?

			멀티스레드
			요청과 응답	stateless
			서버가 가지고 있는 stream을 밀어내주는것이 html
			브라우저는 html을 파싱한다.

			쉬운 프로그램 방식	위직방식
			미래에는 컴포넌트화될것 (지금도 컴포넌트화 하고있다)
			*우리의 목적은 웹컴포넌트를 만드는것이다.
			모듈들을 부품화한다.
			클래스가 모여 컴포넌트 - 컴포넌트가 모여 애플리케이션
			완전한 재사용은 애플리케이션자체를 재사용하는 것.
			

			HTTP	요청)	- 요청메소드(get,post,put...)
					- url(특정문서,자원이있는위치)
					- 전달해야할 parameter
						브라우저에서 서버로 유알엘통해서 연결할때 get/post방식으로 연결한다.
						연결할때 파라메터를 전달한다. 
			
				응답)	- 응답코드(상태코드)ex) 404 .. 403..500....
					- 컨텐츠타입(텍스트,오디오,영상...타입)
					- 컨텐츠(바디)_프로토콜(규격)안에 바디
			html은 서버에 있다. script도 서버에 있다. 동작은 브라우저에서
	

	servlet / JSP	있는것도 동작,처리도 서버에서 하고 결과만 브라우저로 
	Model
	WAS



웹 사이트와 URL
	웹 사이트는 정적 문서로 구성된 사이트

	URL 구성
		protocol://host:port/path/file  -> 기본구성
		http://www.season.com:80/spring/april/html
		http://www.season.com/spring/april/html
		http://www.season.com -> 생략이 됨

	파라메터
		주소 뒤에 추가로 붙는 데이터
		?(물음표)를 사용해서 주소 경로와 구분 (?부터 파라메터 시작)
		http://www.season.com/spring/april/html?weather=sunny&temp=25

	HTTP 메소드 (GET)
		요청 방식에 따라 GET/POST로 구분
		GET 요청 방식
			단순히 서버에게 자원(HTML, 이미지, 문서)을 URL 통해 요청하는 방식
			필요한 데이터를 URL 뒤에 덧붙여 전송
			데이터 크기 제약이 있으며 북마킹을 허용(지원)
			브라우저 캐싱에 의한 보안 문제를 야기한다.(로그인했을때 주소창에 아이디비번 노출 등)? ->post를 써야한다.
		POST 요청방식
			주로 폼에서 사용되는 방식으로 웹 컨텐츠의 내용을 변경하기 위해 사용
			get은 뭔가를 읽어온다. post는 뭔가를 바꾼다.(정보를 새로 db에 넣는다./로그인은 보안문제로 post사용)
			get을 써야할 때 post를 쓰면? - 북마킹이 안된다. / 검색이 안된다.
			필요한 데이터를 HTTP요청의 메세지 바디를 통해 전송
			데이타의 양이 많거나 URL에 노출되지 말아야할 때 사용
			

웹 애플리케이션
	웹 사이트 + Dynamic working service (CGI Processing)
	CGI (Common Gateway Interface)
		- 웹서버에 존재하는 프로그램을 호출할 수 있는 기술
		   원격호출 어떻게 호출하는가..? 그것에 대한 표준화를 한 것이 CGI	

		- 웹 애플리케이션이 동작되는 서버 - WAS
		- Perl, C 등 다양한 언어로 작성되었었다. 
		- 위를 지금 거의 안쓰는 이유는 Process loading방식이기 때문
			프로세스의 중요성***

	ASP.NET, Servlet/JSP



웹 컨테이너
	웹 컨테이너가 있으면 웹 컴포넌트가 있다.
	servlet/JSP가 웹 컴포넌트
	tomcat은 웹 컨테이너

	컴포넌트 - 생각을 재사용 ..?
	프레임 - GUI컨테이너 - 컨테이너 안에 컴포런트
	컴포런트 -파일    /     컨테이너 - _ ?

	- 웹컴포넌트(servlet/jsp 등) 실행 관리를 위한 프레임워크
	   ex) 톰캣, 레진, Glassfish 등
	- 서블릿과 웹 서버간의 커뮤니케이션 지원
		(웹서버 - 정적문서처리  웹컨테이너- 자바기술을 사용하기위해 -동적문서처리)
		톰캣이 어느정도 웹서버 역할을 한다. 대부분 동적문서처리
		(우리는 대부분 동적문서를 할꺼라 톰캣만으로 가능할것..)
	 - 서블릿 라이프사이클 관리 
			(참고 : 로컬베리어블은 메소드 밖으로 가면 사라진다)
		작업관리자를 켜둘것
	- 요청에 대한 멀티 스레딩 지원
		스레드를 컨테이너가 자체적으로 제공해준다.
	- 보안 및 오류에 대한 처리 지원
		웹컨테이너 웹컴포넌트를 잘 알면 전체를 이해 하기 좋다..


servlet -> server + let 작은 서버
	doGet / doPost 오버라이딩 하기
	


Servlet 인터페이스와 서블릿 라이프사이클
	init()/service()/destory()/getServletConfig()
	
	1. 요청에 의해 특정 서블릿 호출
	2. 해당 서블릿 생성 및 로드 (여기까지는 자바와 동일)
	3. init() 메소드 호출 (최초 1회 호출)
	4. service() 메소드 호출 (doGet/doPost)
	5. destroy() 메소드 호출 (destroy()가 오버라이딩 되었다는 가정하에 service()가 소멸 되기 전 destory()를 호출한다.)
						  (톰캣을 내릴때 destroy()호출을 확인할 수 있다. 통상적으로 확인하기 어려움)
						- 최초 사용자에 대한 이야기 / 최초 이후에는 init()호출안함
						 
	init() service() destroy()에 각각 무엇을 적어야할까?
	init() - 필요한 초기화 작업들
	service() -
	destroy() - 초기화 했던 작업들을 제거할때 사용
	
	init_초기화 desroy_파괴하다
	

인터페이스 - 객체를 만들수없다 추상화할수 없다?


false로 두고 


https://javaee.github.io/javaee-spec/javadocs/

os공부 필요


******반드시 기억할 것******
Tomcat
	-webapps(웹애플리케이션)
		-root
		-jv301 (패키지 아니고 애플리케이션jv301) -properties-web project settings-
				http://localhost:8080/root
				http://localhost:8080/jv301
				http://localhost:8080/jv301/mod004/abc.html
			-index.html(홈페이지는 대부분 인덱스페이지)
			-[폴더](ex)_mod004)
				-index(ex)_abc.html)
				-index
			-[폴더]
				-index
				-index       	 css /javascrpt 등이 WEB-INF위에 있다.
			-[WEB-INF](대분자구분) *외부로부터 직접적 접근을 허용하지 않는다. /servlet/com.varxyz.js301.mod004/AbcServlet .. 그러나 보안문제로 매핑을 한다. /mod004/abc.view로 한다.
								 http://localhost:8080/jv301/mod004/abc.view
								 http://localhost:8080/jv301/config.view (.view는 내가 정의)
				-web.xml(D.D)
				-classes
					-java (servlet..)
					-com.varxyz.js301.mod004
						-mod004
							-AbcServlet.class

jv301을 묶어서 jv301.war로 압축파일 만듬 _ 컴포넌트



숙제)
	지금 우리가 만든 것
	한쪽은 고객(운영자)()
	한쪽은 시스템개발
	고객과 시스템개발자 간에 질문과 답변을 통해 요구사항을 파악해야한다. 15~17개 내로 요구사항 리스트만들기
	

	

회원가입 폼(add_user.html)
	회원 아이디 : userId
	비밀번호 :	passwd
	이름 : userName
	주민번호 : ssn(앞의 6자리만)
	이메일1 : email1(아이디)
	이메일2 : email2(메일도메인 ex: naver.com, gmail.com ... 셀렉트박스)
	관심분야 :	connerns(체크박스 : 다중선택가능, ex: Java, Servlet/JSP, EJB, Android, Spring)
	
회원가입 서블릿(AddUserServlet.java)
	회원이 등록한 정보를 받아 회원가입에서 입력한 정보를 출력

회원가입 폼 작성시, 스크립트나 css 사용가능
체크박스처럼 하나 이상의 값이 전달되는 경우 서블릿에서 파라메터 정보 받는 법
	String[] concerns = request.getParameterValues("concerns");
	
	

get방식하면 주소창에 데이터가 다 나온다..
개인정보나 데이터 양이 많을 때 post방식 사용











JSP (Java Server Page)
	-. 사용자를 위한 동적 뷰를 제공한다.
	-. 프리젠테이션 코드를 서블릿이 아닌 JSP를 통해 작성함으로써 코드 작성을 간소화
	-. 서블릿과 JSP를 상호보완적으로 사용함으로써 Model2 아키텍쳐 기반의 애플리케이션을 작성한다.
	-. 웹 디자이너와 프로그래머의 역할 구분을 보다 증진시킨다.
	
JSP 특징
	-. 기본적으로 JSP는 서블릿 인스턴스로 변환된다. (동일 테크놀리지)
	-. JSP페이지를 작성한 후 저장하면 컨테이너에 의해 (java)소스변환, 컴파일, 실행이 자동으로 이뤄진다.
		hello.jsp  ===>  hello.java  ===>  hello.class  ===>   실행(서블릿)
		       (translation)       (compile)          (runtime)
	-. JSP는 서블릿보다 작성 과정이 간단하지만 디버깅은 상대적으로 어렵다.
		JSP 단점 : 톰캣없이는 브라우저를 볼 수 없다. 레이아웃을 제공하지 않는다.
		
JSP 라이프사이클
	-. 기본적으로 서블릿과 동일
	-. jspInit()메소드
			초기화, 오버라이딩
	-. jspDestroy()메소드
			소멸, 해제, 오버라이딩
	-. _jspService()메소드
			jsp페이지 자신, 오버라이딩 불가능

JSP 파일 저장 위피
	-. JSP는 html과 동일 위치상에 저장 가능  //현재는 여기 저장할 예정
	-. WED_INF의 하위 폴더에서도 저장 가능   //spring 때는 여기 저장할 예정
	
JSP 주요 태그
	주석		 :	JSP주석 <&-- --&>은 브라우저에서 안보인다.
				HTML주석 <-- -- >은 브라우저에서 보인다.
				등 다른 주석들도 사용가능
	
	지시자	 :	<%@ page %>, <%@ include %>, <%@ taglib %> 첫줄에 지시 / import도 지시자 안에 쓴다.
	(directive)
	
	스크립팅	 :	<%! 멤버선언 %>, <% 자바코드 %>, <%= 출력 %>
	엘리먼트
	
	표현식	 :	${표현식}
	
	커스텀 태그 :	JSTL
	
page 지시자
	import = "java.util.*"
	contentType = "text/html; charset=UTF-8"  	MIME타입과 문자 인코딩 설정
	session = true (디폴트값은 true)				해당페이지에서 세션을 지원하려면 true
	errorPage = "에러를 처리할 페이지"
	isErrorPage = "true" (디폴트값은 false)			이 값이 true일 때 exception내장 객체 사용가능
	pageEncoding								JSP페이지의 문자 인코딩을 정의(ISO-8859-1)
	(그 밖에 isELIgnored, isThreadSafe, language, extends, butter, autoFlush, info)extends는 절대 쓰면안된다.
	
스크립틀릿
	JSP페이지내에서 자바코드<% %>를 사용할 수 있도록한다. 
	주의할 점은 스크립틀릿 내에 자바코드와 HTML코드는 분리되어서 처리되어야한다.
	스크립틀릿 코드의 남용은 코드에 대한 가독성을 떨어뜨리고 유지보수를 어렵게 한다.
	<%
		if(age > 10){
	%>
			You need a ticket.
	<%	}else{
	%>
			You are free.
	<%
		}
	%>
	
표현식
	Ten is <%= (2 * 5) %>
	Thank you, <b> <%= name %> </b> for registration.
	The Current day and time is <%= new java.util.Date() 0.0. %>
	
	
	



MVC(사진참고 숙지할것)- view / controller / model

MVC패턴
	-. UI개발자와 비즈니스개발자와의 분업 개발 제공
	-. 동시 사용자 증가에 따른 시스템 확장성 제공
	-. Low coupling, High cohesion을 통한 시스템 유지 보수의 편리성 제공
		- 한쪽의 변화에 대해 다른한쪽이 그 변화를 적게 가져가는 것 - Low coupling
		
모델 2아키텍처
	-. 썬 마이크로시스템의 베스트 가이드라인
	-. MVC패턴 구현을 위한 베스트 컴포넌트
		Model 		: (프라이머리)Java, Java Beans, EJB  (세컨더리)DAO, DTO
		View		: 		   HTML, JSP, XML                 Servlet
		Controller 	:          Servlet						  JSP     
		
컨트롤러의 주요 역할
	서블릿에 의해 구현될 컨트롤러는 다음과 같은 역할을 처리한다.
	-. 클라이언트의 요청 파라메타 정보를 구한다. (getParameter / getParameterValues / getParameterNames)
	-. 요청 파라메타에 대한 유효성 검증 및 데이터 변환 작업을 처리한다. (스프링은 이 내용을 따로 한다. / 시간이 없을때는 스크립트에서)
	-. 요청 처리에 필요한 비즈니스 오퍼레이션을 호출한다.
	-. 요청 처리 결과에 따라 클라이언트에세 보여줄 뷰를 선택한다.
	
서블릿 커뮤니케이션
	-. 서블릿은 다른 서블릿과 커뮤니케이션이 일반 객체와 달리 제약적이다.
		- 사용자가 서블릿 갹체를 직접 생성하지 않는다.
		- 기본적으로 특정 서비스를 위해 하나의 서블릿 인스턴스를 생성한다.
	-. 따라서 요청 처리를 다른 자원으로 위임할 수 있는 방법이 필요하다. (DB는 서버다운할 때 데이타베이스를 보관한다.)

속성 *Scope과 RequestDispatcher
	-. RequestDispatcher인터페이스는 서블릿에서 다른 페이지로 포워드할 수 있는 메소드를 제공
	-. 속성 scope은 다른 서블릿과 공유해야 할 데이터를 임시적으로 저장할 수 있는 기능을 제공
	-. request, session, application, page (맵에 데이터보관하는 건데 언제 사라지는지 차이가 있다)
					리퀘스트사이클 / 지금은 리퀘스트만 알아둘것
					request scope - 요청과 응답사이(request) 시간이 길다  
					session scope - 로그아웃해야 사라짐
					application scope - 로그아웃해도 안사라짐 여러사람 들어와도 남아있음 애플리케이션 셧다운 되야 사라짐
					   page scope - 페이지 벗어나면 사라짐(잘 사용하진 않음)
				
			setAttribute(String name, Object obj)
			getAttribute(String name)
			
			-- 서블릿 --
			request.setAttribute("userName", userName);
			RequestDispatcher dispatcher = request.getRequestDispatcher("success.jsp");
			dispatcher.forward(request, response);
			
			-- JSP --
			String userName = (String)resquest.getAttribute("userName");                                                                                                                                                                                                                                                                                                   